(* Copyright 2018, Kevin Lang, Oath Research *) 

(*
The column permutations that the CPC implementation uses 
while compressing the SLIDING flavor can be generated by
typinc the following commands into a shell:

$ ~/ocaml-4.03.0/bin/ocaml
#print_length 10000;;
#use "columnProbabilities.ml";;
#use "generatePermutationsForSLIDING.ml";;

This will print out something like the following, which can be 
manually converted to C syntax by mapping "[| ; |]" to "{ , }".

  [|[|0; 1; 2; 3; 5; 6; 7; 8; 9; 10; 11; 12; 13; 15; 16; 17; 18; 19; 20; 21;
      22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 35; 36; 37; 38; 39; 40;
      41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 34; 14; 4|];
    [|0; 1; 2; 3; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 16; 17; 18; 19; 20; 21;
      22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 36; 37; 38; 39; 40;
      41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 35; 15; 4|];
...
    [|0; 1; 2; 4; 5; 6; 7; 8; 9; 10; 11; 12; 14; 15; 16; 17; 18; 19; 20; 21;
      22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 33; 34; 35; 36; 37; 38; 39; 40;
      41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 32; 13; 3|]
    |]

*)

(******************************************************)

let calculate_the_probabilities phase = begin
  let kf = 2.0 ** 32.0 in 
  let nf = accurate_n_of_c kf (kf *. (30.0 +. phase)) in
  let first_col_of_byte = if phase < asymptotic_shift_phase then 28 else 29 in (* 1-based column numbering *)

  let entropy_lo = ref 0.0 in
  let accum_lo   = ref [] in
  for col = first_col_of_byte-1 downto first_col_of_byte-8 do
    let (p1, lg1, p0, lg0) = prob_of_1_and_0_with_their_logs kf (float col) nf in
    entropy_lo := !entropy_lo -. (p1 *. lg1 +. p0 *. lg0);
    accum_lo := p0 :: !accum_lo;
  done;

  let accum_hi = ref [] in
  let entropy_hi = ref 0.0 in
  for col = first_col_of_byte+8+0 to first_col_of_byte+8+55 do
    let (p1, lg1, p0, lg0) = prob_of_1_and_0_with_their_logs kf (float col) nf in
    entropy_hi := !entropy_hi -. (p1 *. lg1 +. p0 *. lg0);
    accum_hi := p1 :: !accum_hi;
  done;

  let accum_mid = ref [] in
  let entropy_mid = ref 0.0 in
  for col = first_col_of_byte+0 to first_col_of_byte+7 do
    let (p1, lg1, p0, lg0) = prob_of_1_and_0_with_their_logs kf (float col) nf in
    entropy_mid := !entropy_mid -. (p1 *. lg1 +. p0 *. lg0);
    accum_mid := (min p0 p1) :: !accum_mid;
  done;


  (!entropy_lo,
   !entropy_hi,
   !entropy_mid,
   Array.of_list (List.rev !accum_lo),
   Array.of_list (List.rev !accum_hi))
end

(******************************************************)

let invert_permutation perm_in = begin
  let  len = Array.length perm_in in
  let perm_out = Array.make len 0 in
  for i = 0 to len-1 do
    perm_out.(perm_in.(i)) <- i;
  done;
  perm_out
end


(******************************************************)

(* creates a permutation of length 56 *)

let generate_permutation phase = begin
  let (ll, hh, mm, arr_lo, arr_hi) = calculate_the_probabilities phase in
  assert (Array.length arr_lo = 8);
  assert (Array.length arr_hi = 56);
  let work = Array.copy arr_hi in
  for i = 0 to 7 do
    work.(56-i-1) <- max work.(56-i-1) arr_lo.(i);
  done;
  let work2 = Array.init 56 (fun i -> (work.(i), i)) in
  Array.sort rev_compare work2;
  let back = Array.map snd work2 in
  let forw = invert_permutation back in
  let check = invert_permutation forw in
  assert (back = check);
  forw
end

(******************************************************)

let result = Array.init 16 (fun i -> let numer =  1+2*i in generate_permutation ((float numer) /. 32.0))

